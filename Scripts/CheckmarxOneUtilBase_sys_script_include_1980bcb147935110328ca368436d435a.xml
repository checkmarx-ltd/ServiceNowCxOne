<?xml version="1.0" encoding="UTF-8"?>
<unload unload_date="2024-03-08 07:43:10">
<sys_script_include action="INSERT_OR_UPDATE">
<access>public</access>
<active>true</active>
<api_name>x_chec3_chexone.CheckmarxOneUtilBase</api_name>
<caller_access/>
<client_callable>false</client_callable>
<description>Wrapper class to assemble the components for Checkmarx One integration calls.</description>
<name>CheckmarxOneUtilBase</name>
<script><![CDATA[var CheckmarxOneUtilBase = Class.create();

CheckmarxOneUtilBase.prototype = {
    MSG: 'CheckmarxOneUtilBase:',
    initialize: function() {},

    //get all project list
    getProjectList: function(configId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var baseUrl = config.checkmarxone_server_url;
            var apiurl = config.checkmarxone_api_base_url;
            var method = "post";
            var query = '/api/projects';
            var token = this.getAccessToken(baseUrl, config, method, request, configId);
        } catch (err) {
            gs.error(this.MSG + " getProjectList : Error while getting the project list." + err);
            throw err;
        }
        return this._makeRestApiCall(apiurl, configId, token, query, "get");
    },
    //get one project from project list for pre Validation
    getProjectListForValidation: function(config) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var configId = "1234";
            var save_token_flag = "false";
            var token = this.getNewToken(accesscontrolbaseUrl, config, method, request, config.client_id, config.client_secret, config.tenant, save_token_flag, configId);
            var query = '/api/projects/?offset=0&limit=1';
        } catch (err) {
            gs.error(this.MSG + " getProject: Error while getting project." + err);
            throw err;
        }
        return this._makeRestCall(apibaseurl, configId, token, query, "get");
    },

    //get one project from project list
    getProject: function(configId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var save_token_flag = "true";
            var token = this.getNewToken(accesscontrolbaseUrl, config, method, request, config.client_id, config.client_secret, config.tenant, save_token_flag, configId);
            var query = '/api/projects/?offset=0&limit=1';
        } catch (err) {
            gs.error(this.MSG + " getProject: Error while getting project." + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");
    },

    //get new project list
    getNewProjectList: function(configId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var query = '';
            var projectid = '';
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request);
            query = '/api/projects/?offset=0&limit=1';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);
        } catch (err) {
            gs.error(this.MSG + " getProjectInfo: Error while getting the project info." + err);
            throw err;
        }
        return projectJSON;
    },

    //To get Lists of project from Configuration Page
    getConfigProjectList: function(configId) {
        var config = this._getConfig(configId);
        var project_lists = [];
        var list_projects = config.list_of_project_id_s;
        if (list_projects && list_projects.length > 0) {
            var list_project_arr = list_projects.split(";");
            for (var id in list_project_arr) {
                var projectId = list_project_arr[id].trim();
                if (projectId && projectId.length > 0 && project_lists.indexOf(projectId) == -1)
                    project_lists.push(projectId);
            }
        }
        return project_lists;
    },

    //get Project By Id
    getConfigProjectById: function(configId, projectId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/projects/' + projectId;
            var resp = this._makeConfigRestApiCall(apibaseurl, configId, token, query, "get");
        } catch (err) {
            gs.error(this.MSG + " getConfigProjectById: Error while getting the project info." + err);
        }
        return resp;
    },


    //get 50 project list at a time
    getNextProjectList: function(configId, offsetno) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var limit_val = config.limit;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '';
            var projectid = '';
            var list_projects = this.getConfigProjectList(configId);
            if (list_projects && list_projects.length > 0) {
                for (var id in list_projects) {
                    if (list_projects[id].length > 0) {
                        var projectStatus = this.getConfigProjectById(configId, list_projects[id]);
                        if (projectStatus == 200 || projectStatus == 202)
                            projectid += '&ids=' + list_projects[id];
                        else
                            gs.info("Entered project id is wrong" + list_projects[id]);
                    }
                }
                query = '/api/projects/?' + projectid;
            } else {
                query = '/api/projects/?offset=' + offsetno + '&limit=' + limit_val;
            }
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);

        } catch (err) {
            gs.error(this.MSG + " getProjectInfo: Error while getting the project info." + err);
            throw err;
        }
        return projectJSON;
    },


    //get Project By Id
    getProjectById: function(configId, projectId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/projects/' + projectId;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);

        } catch (err) {
            gs.error(this.MSG + " getProjectInfo: Error while getting the project info." + err);
            throw err;
        }
        return projectJSON;
    },

    //get Project By Name
    getProjectByName: function(configId, projectName) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/projects/?offset=0&limit=1&name-regex=' + projectName;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);

        } catch (err) {
            gs.error(this.MSG + " getProjectInfo: Error while getting the project info." + err);
            throw err;
        }
        return projectJSON;
    },

    //List of scanIds for a given app/project
    getScanList: function(configId, projectId, last_run_date) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=1&statuses=Completed&project-id=' + projectId + '&from-date=' + last_run_date + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
        } catch (err) {
            gs.error(this.MSG + " :getScanList :Error in getting status of the report." + err);
            return -1;
        }

        return resp;

    },

    //Second Last scanId for a given app/project
    getSecondLastScan: function(configId, projectId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=1000&statuses=Completed&project-id=' + projectId + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var secondscan = -1;
            var ScanJson = JSON.parse(body);
            for (var i = 0; i <= ScanJson.scans.length; i++) {
                if (ScanJson.scans[i] != undefined) {
                    if (ScanJson.scans[i].id == scanId && ScanJson.scans[i + 1] != undefined) {
                        secondscan = ScanJson.scans[i + 1].id;
                    }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " :getSecondLastScan :Error in getting status of the report." + err);
            throw err;
        }
        return secondscan;
    },

    // last  scan details of a given appId 
    getScanInfo: function(configId, appId, offset, last_run_date) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var limit_val = config.limit;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=1&statuses=Completed&project-id=' + appId + '&from-date=' + last_run_date + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';
        } catch (err) {
            gs.error(this.MSG + " getScanInfo: Error while getting the scan Ids." + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");

    },

    //List of Last scanId for a given app/project
    getLastScan: function(configId, projectId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&amp;limit=1&amp;statuses=Completed&amp;project-id=' + projectId + '&amp;sort=%2Bcreated_at&amp;sort=%2Bstatus&amp;field=scan-ids';

        } catch (err) {
            gs.error(this.MSG + " :getScanList :Error in getting status of the report." + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");
    },

    // last  scan details of a given scanId 
    getLastScanInfo: function(configId, appId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/' + scanId;
        } catch (err) {
            gs.error(this.MSG + " getScanInfo: Error while getting the scan Ids." + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");

    },


    //scan details of a given scanId
    getQueryInfo: function(configId, scanId) {
        var queryJSON;
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/results/?scan-id=' + scanId + '&offset=0&limit=10000&sort=%2Bstatus&sort=%2Bseverity';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            queryJSON = JSON.parse(body);
        } catch (err) {
            gs.error(this.MSG + " getQueryInfo: Error while getting the Query Info.");
            throw err;
        }
        return queryJSON;

    },

    processQueryData: function(configId, scanId) {
        var queryJSON = this.getQueryInfo(configId, scanId);
        var query = [];
        var index = 0;
        for (item in queryJSON.results) {
            var singleQuery = queryJSON.results[item];
            if (singleQuery.type == 'sast' || singleQuery.type == 'kics') {
                var queryIndex = this.checkQueryIndex(query, singleQuery.data.queryName);
                if (queryIndex != -1)
                    query[queryIndex].count = query[queryIndex].count + 1;
                else {
                    var updatedQuery = {};
                    updatedQuery.category_name = singleQuery.data.queryName;
                    updatedQuery.severity = singleQuery.severity;
                    updatedQuery.count = 1;
                    query[index] = updatedQuery;
                    index++;
                }
            }
        }
        return query;
    },

    checkQueryIndex: function(query, name) {
        for (queryIndex in query)
            if (query[queryIndex].category_name === name)
                return queryIndex;
        return -1;
    },

    // to fetch scan details of particular scanId
    getScanDetails: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=2000&scan-ids=' + scanId + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';


        } catch (err) {
            gs.error(this.MSG + " getScanDetails: Error while getting the scan Ids." + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");

    },

    //to get total  vul item 
    getTotalVulcount: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var includesca = this.importScaFlaw(configId);
            var includesast = this.importSastFlaw(configId);
            var includekics = this.importKicsFlaw(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var vulnerabilityCountThresholdLevel = config.vulnerability_threshold_level;
            var method = "post";
            var count = 0;
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);
            for (var item in ScanSummaryJson.scansSummaries) {
               
                    for (var value in ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters) {
                        var severity = ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters[value].severity;
                        if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                            (vulnerabilityCountThresholdLevel == 'LOW' && severity.toUpperCase() != 'INFO') ||
                            (vulnerabilityCountThresholdLevel == 'MEDIUM' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW') ||
                            (vulnerabilityCountThresholdLevel == 'HIGH' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW' && severity.toUpperCase() != 'MEDIUM') ||
                            severity.toUpperCase() == 'CRITICAL') {
                            var counts = ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters[value].counter;
                            count += counts;
                        }
                    }

                    for (var sca_value in ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters) {
                        var sca_severity = ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters[sca_value].severity;
                        if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                            (vulnerabilityCountThresholdLevel == 'LOW' && sca_severity.toUpperCase() != 'INFO') ||
                            (vulnerabilityCountThresholdLevel == 'MEDIUM' && sca_severity.toUpperCase() != 'INFO' && sca_severity.toUpperCase() != 'LOW') ||
                            (vulnerabilityCountThresholdLevel == 'HIGH' && sca_severity.toUpperCase() != 'INFO' && sca_severity.toUpperCase() != 'LOW' && sca_severity.toUpperCase() != 'MEDIUM') ||
                            sca_severity.toUpperCase() == 'CRITICAL') {
                            var sca_counts = ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters[sca_value].counter;
                            count += sca_counts;
                        }
                    }
                    for (var sca_container_value in ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters) {
                        var sca_container_severity = ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters[sca_container_value].severity;
                        if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                            (vulnerabilityCountThresholdLevel == 'LOW' && sca_container_severity.toUpperCase() != 'INFO') ||
                            (vulnerabilityCountThresholdLevel == 'MEDIUM' && sca_container_severity.toUpperCase() != 'INFO' && sca_container_severity.toUpperCase() != 'LOW') ||
                            (vulnerabilityCountThresholdLevel == 'HIGH' && sca_container_severity.toUpperCase() != 'INFO' && sca_container_severity.toUpperCase() != 'LOW' && sca_container_severity.toUpperCase() != 'MEDIUM') ||
                            sca_container_severity.toUpperCase() == 'CRITICAL') {
                            var sca_container_counts = ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters[sca_container_value].counter;
                            count += sca_container_counts;
                        }
                    }
                    for (var kics_value in ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters) {
                        var kics_severity = ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters[kics_value].severity;

                        if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                            (vulnerabilityCountThresholdLevel == 'LOW' && kics_severity.toUpperCase() != 'INFO') ||
                            (vulnerabilityCountThresholdLevel == 'MEDIUM' && kics_severity.toUpperCase() != 'INFO' && kics_severity.toUpperCase() != 'LOW') ||
                            (vulnerabilityCountThresholdLevel == 'HIGH' && kics_severity.toUpperCase() != 'INFO' && kics_severity.toUpperCase() != 'LOW' && kics_severity.toUpperCase() != 'MEDIUM') ||
                            kics_severity.toUpperCase() == 'CRITICAL') {
                            var kics_counts = ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters[kics_value].counter;
                            count += kics_counts;
                        }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getTotalVulcount: Error while getting the total vul count." + err + scanId);
            return -1;
        }

        return count;

    },


    //to get SAST  vul item 
    getSASTVulcount: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);

            for (var item in ScanSummaryJson.scansSummaries) {
                var count = ScanSummaryJson.scansSummaries[item].sastCounters.totalCounter;
            }
        } catch (err) {
            gs.error(this.MSG + " getSASTVulcount: Error while getting the SAST vul count." + err + scanId);
            return -1;
        }

        return count;

    },

    //to get total SAST and KICS  vul item 
    getTotal_SAST_KICS_Vulcount: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var flaws = 0;
            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);

            for (var item in ScanSummaryJson.scansSummaries) {
                var counts = ScanSummaryJson.scansSummaries[item].sastCounters.totalCounter + ScanSummaryJson.scansSummaries[item].kicsCounters.totalCounter;
                flaws += counts;
            }
        } catch (err) {
            gs.error(this.MSG + " getTotalVulcount: Error while getting the total vul count." + err + scanId);
            return 0;
        }

        return flaws;

    },

    // to get vulnerabilities information of scanId
    getVulInfo: function(configId, scanId, offsetId, delta) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var includesca = this.importScaFlaw(configId);
            var includesast = this.importSastFlaw(configId);
            var includekics = this.importKicsFlaw(configId);

            var limit_val = config.limit;
            var query = '/api/results/?scan-id=' + scanId + '&offset=' + offsetId + '&limit=' + limit_val + '&sort=-severity'; 
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

        } catch (err) {
            gs.error(this.MSG + " getVulInfo: Error while getting the vul Info." + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");

    },

    //Sca scan details of a given scanId
    getScanSummaryInfo: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);
            var flaws = 0;
            var vulnerabilityCountThresholdLevel = config.vulnerability_threshold_level;
            for (var item in ScanSummaryJson.scansSummaries) {
                for (var value in ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters) {
                    var severity = ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters[value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW' && severity.toUpperCase() != 'MEDIUM') ||
                        severity.toUpperCase() == 'CRITICAL') {
                        var counts = ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters[value].counter;
                        flaws += counts;
                    }
                }
                for (value in ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters) {
                    var sca_container_severity = ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters[value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && sca_container_severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && sca_container_severity.toUpperCase() != 'INFO' && sca_container_severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && sca_container_severity.toUpperCase() != 'INFO' && sca_container_severity.toUpperCase() != 'LOW' && sca_container_severity.toUpperCase() != 'MEDIUM') ||
                        sca_container_severity.toUpperCase() == 'CRITICAL') {
                        var sca_container_counts = ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters[value].counter;
                        flaws += sca_container_counts;
                    }
                }
            }

        } catch (err) {
            gs.error(this.MSG + " getScanSummaryInfo: Error while getting the scan summary Ids." + err + scanId);
            return -1;

        }
        return flaws;

    },

    //Sast scan details of a given scanId
    getSastScanSummaryInfo: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);
            var flaws = 0;
            var vulnerabilityCountThresholdLevel = config.vulnerability_threshold_level;
            for (var item in ScanSummaryJson.scansSummaries) {
                for (var value in ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters) {
                    var severity = ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters[value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW' && severity.toUpperCase() != 'MEDIUM') ||
                        severity.toUpperCase() == 'CRITICAL') {
                        var counts = ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters[value].counter;
                        flaws += counts;
                    }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getScanSummaryInfo: Error while getting the scan summary Ids." + err + scanId);
            return -1;
        }
        return flaws;

    },

    //Kics scan details of a given scanId
    getKicsScanSummaryInfo: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);
            var flaws = 0;
            var vulnerabilityCountThresholdLevel = config.vulnerability_threshold_level;
            for (var item in ScanSummaryJson.scansSummaries) {
                for (var value in ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters) {
                    var severity = ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters[value].severity;

                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW' && severity.toUpperCase() != 'MEDIUM') ||
                        severity.toUpperCase() == 'CRITICAL') {
                        var counts = ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters[value].counter;
                        flaws += counts;
                    }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getScanSummaryInfo: Error while getting the scan summary Ids." + err + scanId);
            return -1;

        }
        return flaws;

    },

    getDeltaScan: function(configId, appId, scanId, secondlastscan, offsetId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var limit_val = config.limit;
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request);
            var offset = offsetId * 50;
            var query = '/api/sast-results/compare?scan-id=' + scanId + '&base-scan-id=' + secondlastscan + '&offset=' + offset + '&limit=' + limit_val;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
        } catch (err) {
            gs.error(this.MSG + " getDeltaScan: Error while getting the delta state." + err + scanId);
            return -1;
        }
        return resp;

    },

    //To get remediation status for state mapping
    getSASTRemediationStatus: function(status, state) {
        try {

            if (state == 'TO_VERIFY' || status == 'FIXED' || status == 'RESOLVED') {
                var remediation_status = status;
            } else {
                remediation_status = state;
            }
        } catch (err) {
            gs.error(this.MSG + " getRemediationStatus: Error while getting the status." + err);

        }
        return remediation_status;

    },

    //To get remediation status for state mapping
    getSCARemediationStatus: function(status, state) {
        try {

            if (state == 'NOT_IGNORED' || status == 'FIXED' || status == 'RESOLVED' || state == 'TO_VERIFY') {
                var remediation_status = status;
            } else {
                remediation_status = state;
            }
        } catch (err) {
            gs.error(this.MSG + " getRemediationStatus: Error while getting the status." + err);

        }
        return remediation_status;

    },

    //To get remediation status for state mapping
    getKICSRemediationStatus: function(status, state) {
        try {

            if (state == 'NOT_IGNORED' || status == 'FIXED' || status == 'RESOLVED' || state == 'TO_VERIFY') {
                var remediation_status = status;
            } else {
                remediation_status = state;
            }
        } catch (err) {
            gs.error(this.MSG + " getRemediationStatus: Error while getting the status." + err);

        }
        return remediation_status;

    },

    getFirstDetectionDate: function() {
        try {
            var configId = '1234';
            var config = this._getConfig(configId);
            var include_first_found = config.include_first_detection_date;
        } catch (err) {
            gs.error(this.MSG + " getFirstDetectionDate: Error while getting the status of getFirstDetectionDate." + err);

        }
        return include_first_found;
    },

    //Devops Integration
    getProjectByLegacyId: function(configId, params) {
        return this._makeRestCallJSON(configId, 'Project list', JSON.parse(params));
    },

    _getConfig: function(configId) {
        try {
            if (configId && configId != '1234') {
                return new sn_sec_int.Implementation().getConfiguration(configId);
            } else {
                var gr = new GlideRecord("x_chec3_chexone_checkmarxone_configuration");
                gr.query();
                gr.next();
                var newconfig = {
                    "client_secret": gr.client_secret.getDecryptedValue(),
                    "client_id": gr.getValue("client_id"),
                    "tenant": gr.getValue("tenant"),
                    "checkmarxone_api_base_url": gr.getValue("checkmarxone_api_base_url"),
                    "checkmarxone_server_url": gr.getValue("checkmarxone_server_url"),
                    "limit": gr.getValue("limit"),
                    "log_level": gr.getValue("log_level"),
                    "include_first_detection_date": gr.getValue("include_first_detection_date") === "1",
                    "import_sca": gr.getValue("import_sca") === "1",
                    "import_sast": gr.getValue("import_sast") === "1",
                    "import_kics": gr.getValue("import_kics") === "1",
                    "triaging_in_snow": gr.getValue("triaging_in_snow") === "1",
                    "access_token": gr.access_token.getDecryptedValue(),
                    "vulnerability_threshold_level": gr.getValue("vulnerability_threshold_level"),
                    "list_projects": gr.getValue("list_of_project_id_s"),
                };
            }
        } catch (err) {
            gs.error(this.MSG + " :_getConfig :Error in getting the configuration." + err);
            throw err;
        }
        return newconfig;
    },

    getAccessToken: function(baseUrl, config, method, request, configId) {
        return this._getToken(baseUrl, config, method, request, config.client_id, config.client_secret, config.ast_client_id, config.tenant, config.access_token, configId);
    },

    _getToken: function(baseUrl, config, method, request, username, password, ast_client_id, tenant, currentToken, configId) {
        try {
            var accessToken = currentToken;
            if (accessToken == null || accessToken == "" || this._isTokenExpired(this._getExpTimeFromAccessToken(accessToken)) || !this._checkClientId(username, accessToken)) {
                gs.info("Token is expired or client Id is changed, Recreating token..");
                var fullUrl = baseUrl + '/auth/realms/' + tenant + '/protocol/openid-connect/token';
                var query = "client_id=" + username + "&grant_type=" + "client_credentials" + "&client_secret=" + password;
                request.setEndpoint(fullUrl);
                request.setHttpMethod(method);
                var log_level = config.log_level;
                request.setLogLevel(log_level);
                request.setRequestBody(query);
                request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                request.setRequestHeader("Accept", "application/json");
                request.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
                //Convert the object to string and set it to Request Body-
                request.setRequestBody(query);
                var response = this._checkResponseStatus(request);
                var responseBody = response.getBody();
                var tokenResponse = JSON.parse(responseBody);
                accessToken = tokenResponse.access_token;
                this.saveInstanceTokens(config, accessToken, configId);
            }

        } catch (err) {
            gs.error(this.MSG + " :_getToken : Error while getting the token." + err);
            throw err;
        }
        return accessToken;
    },

    getNewToken: function(baseUrl, config, method, request, username, password, tenant, saveinstanceflag, configId) {

        try {
            var fullUrl = baseUrl + '/auth/realms/' + tenant + '/protocol/openid-connect/token';
            var query = "client_id=" + username + "&grant_type=" + "client_credentials" + "&client_secret=" + password;
            request.setEndpoint(fullUrl);
            request.setHttpMethod(method);
            var log_level = config.log_level;
            request.setLogLevel(log_level);
            request.setRequestBody(query);
            request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            request.setRequestHeader("Accept", "application/json");
            request.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            //Convert the object to string and set it to Request Body-
            request.setRequestBody(query);
            var response = request.execute();
            var status = response.getStatusCode();
            var accessToken = '';
            if (status == 200 || status == 202) {
                var responseBody = response.getBody();
                var tokenResponse = JSON.parse(responseBody);
                accessToken = tokenResponse.access_token;
                if (saveinstanceflag == "true") {
                    this.saveInstanceTokens(config, accessToken, configId);
                }

            }

        } catch (err) {

            gs.error(this.MSG + " :getNewToken : Error while getting the token." + err);
            throw err;

        }

        return accessToken;

    },

    getUserAgentHeaderDetails: function() {
        try {
            var plugin = new GlideRecord("sys_store_app");
            plugin.get("scope", "x_chec3_chexone");
            var pluginname_version = "plugin_name=" + plugin.getValue("name") + ";plugin_version=" + plugin.getValue("version");
            return pluginname_version.toString();
        } catch (err) {
            gs.error(this.MSG + " :_getUserAgentHeaderDetailsn : Error while getting the plugin name and version." + err);
            throw err;

        }
    },

    //Compare current clientId with accessToken's clientId
    _checkClientId: function(clientId, accessToken) {
        try {
            var tokenPayload = accessToken.split(".")[1];
            var tokenPayloadJson = JSON.parse(gs.base64Decode(tokenPayload));
            var clientIdToken = tokenPayloadJson.azp;
            if (clientId == clientIdToken)
                return true;
            return false;
        } catch (err) {
            gs.error(this.MSG + " :checkClientId :Error in checkClientId." + err);
            return false;
        }

    },
    // Get expiry token from JWT access token
    _getExpTimeFromAccessToken: function(accessToken) {
        try {
            var splittedStr = accessToken.split(".");
            var decodedToken = JSON.parse(gs.base64Decode(splittedStr[1]));
            var expTime = decodedToken.exp;
        } catch (err) {
            gs.error(this.MSG + " :getExpTimeFromAccessToken :Error in getExpTimeFromAccessToken.");
            return 0;
        }
        return expTime;
    },
    // This method checks  if access token is expired or not.
    _isTokenExpired: function(tokenExpTime) {
        try {
            if (tokenExpTime == 0)
                return true;
            var dateTime = new GlideDateTime();
            var currentTime = dateTime.getNumericValue() / 1000;
            currentTime = parseInt(currentTime);
            if (currentTime > tokenExpTime)
                return true;
            else
                return false;
        } catch (err) {
            gs.error(this.MSG + " :isTokenExpired :Error in isTokenExpired()." + err);
            throw err;
        }
    },

    _makeRestCall: function(apiurl, configId, token, apiPath, method, params) {
        var request;
        try {
            request = this.setRequestParams(apiurl, configId, token, apiPath, method, params);
        } catch (err) {
            gs.error(this.MSG + " :_makeRestCall :Error in making the REST call");
            throw err;
        }
        var response = request.execute();
        return response;
    },

    setRequestParams: function(baseUrl, configId, token, apiPath, method, params) {
        try {
            var fullUrl = baseUrl + apiPath;
            var r = new sn_ws.RESTMessageV2();
            r.setEndpoint(fullUrl);
            r.setHttpMethod(method);

            if (params) {
                fullUrl += '/?';
                Object.keys(params).forEach(function(key) {
                    r.setQueryParameter(key, params[key]);
                    fullUrl += key + '=' + gs.urlEncode(params[key]) + '&';
                });
                fullUrl = fullUrl.slice(0, fullUrl.length - 1);
            }
            var newHeader = "Bearer " + token;
            r.setRequestHeader('Authorization', newHeader);
            r.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            r.setHttpTimeout(30000);
            var config = this._getConfig(configId);
            var log_level = config.log_level;
            r.setLogLevel(log_level);
        } catch (err) {
            gs.error(this.MSG + " :setRequestParams :Error in setting the reuest params for REST API call");
            throw err;
        }
        return r;
    },

    _checkResponseStatus: function(request) {
        try {
            var endpoint = request.getEndpoint();
            var response = request.execute();
            var status = response.getStatusCode();
            if (status == 200 || status == 202)
                return response;

            if (status <= 0)
                throw gs.getMessage("Request could not be completed: {0} Reason : {1}", [endpoint, response.getErrorMessage()]);
            if (status == 400)
                throw gs.getMessage("Bad request: {0} Reason : {1}", [endpoint, response.getErrorMessage()]);
            if (status == 401)
                throw gs.getMessage("Request not authorized: {0}", [endpoint, response.getErrorMessage()]);
            if (status == 403)
                throw gs.getMessage("Request forbidden: {0}", [endpoint, response.getErrorMessage()]);
            if (status == 404)
                throw gs.getMessage("Request not found: {0}", [endpoint, response.getErrorMessage()]);

            throw gs.getMessage('Checkmarx responded with error code {0} on: {1}', [status, endpoint]);
        } catch (err) {
            gs.error(this.MSG + " :_checkResponseStatus :Error in checking the response of the API call.");
            throw err;
        }
    },

    _makeConfigRestApiCall: function(baseUrl, configId, token, name, method) {
        try {
            var fullUrl = baseUrl + name;
            var r = new sn_ws.RESTMessageV2();
            r.setEndpoint(fullUrl);
            r.setHttpMethod(method);
            var newHeader = "Bearer " + token;
            r.setRequestHeader("Accept", "application/json");
            r.setRequestHeader("Authorization", newHeader);
            r.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            r.setHttpTimeout(30000);
            var config = this._getConfig(configId);
            var log_level = config.log_level;
            r.setLogLevel(log_level);
            var response = r.execute();
            var status = response.getStatusCode();
        } catch (err) {
            gs.error(this.MSG + " :_makeConfigRestApiCall :Error in making API call.");
            throw err;
        }
        return status;
    },

    _makeRestApiCall: function(baseUrl, configId, token, name, method, params) {
        try {
            var fullUrl = baseUrl + name;
            var r = new sn_ws.RESTMessageV2();
            r.setEndpoint(fullUrl);
            r.setHttpMethod(method);

            var newHeader = "Bearer " + token;
            r.setRequestHeader("Accept", "application/json");
            r.setRequestHeader("Authorization", newHeader);
            r.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            r.setHttpTimeout(30000);
            var config = this._getConfig(configId);
            var log_level = config.log_level;
            r.setLogLevel(log_level);
        } catch (err) {
            gs.error(this.MSG + " :_makeRestApiCall :Error in making API call.");
            throw err;
        }
        return this._checkResponseStatus(r);
    },
    //For DevOps Integration
    _makeRestCallJSON: function(configId, token, name, params, pathParams, body) {
        var requestType = 'GET';
        var r = new sn_ws.RESTMessageV2('x_chec3_chexone.CheckmarxOneJson', name);
        var endpoint = this._getEndpointComponents(r.getEndpoint());
        if (pathParams) {
            Object.keys(pathParams).forEach(function(key) {
                r.setStringParameter(key, pathParams[key]);
                endpoint.path = endpoint.path.replace('${' + key + '}', pathParams[key]);
            });
        }

        if (params) {
            endpoint.path += '?';
            Object.keys(params).forEach(function(key) {
                r.setQueryParameter(key, gs.urlEncode(params[key]));
                endpoint.path += key + '=' + gs.urlEncode(params[key]) + '&';
            });
            endpoint.path = endpoint.path.slice(0, endpoint.path.length - 1);
        }
        if (!gs.nil(body) && body != {}) {
            requestType = 'POST';
            r.setRequestBody(JSON.stringify(body));
        }


        var newHeader = "Bearer " + token;
        r.setRequestHeader("Accept", "application/json");
        r.setRequestHeader("Authorization", newHeader);
        r.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
        r.setHttpTimeout(30000);
        return this._checkResponseStatus(r);
    },
    // 2022-12-08T09:33:00.028555Z to 2022-12-08 09:33:00
    parseDate: function(str) {
        var a = str.replace('T', ' ');
        var b = a.replace('T', ' ');
        var c = b.split('.')[0];
        var date = new GlideDateTime(c);
        return date;
    },

    //2022-12-08 09:33:00 to 2022-12-08T09:33:00.028555Z
    parseTZDate: function(str) {
        str1 = str.slice(0, str.length - 9) + 'T';
        str2 = str.slice(-8) + '.028555Z';
        if (str == "" || str == null) {
            str3 = str;
        } else {
            str3 = str1 + str2;
        }
        return str3;

    },

    // Saves the access tokens to Service Now configuration DB
    saveInstanceTokens: function(config, accessToken, configId) {
        try {
            var gr = new GlideRecord("x_chec3_chexone_checkmarxone_configuration");
            if (!gs.nil(configId) && configId + '' != '1234') {
                gr.addEncodedQuery("integration_instance=" + configId);

            }
            gr.query();

            var instance = configId;
            var newconfig;
            if (gr.next()) { // In case of default configs
                instance = gr.getValue("integration_instance");
                if (accessToken == 'undefined') {
                    tempAccessToken = gr.access_token.getDecryptedValue(); //config.access_token;				
                } else {
                    tempAccessToken = accessToken;
                }

                gr.access_token.setDisplayValue(tempAccessToken);
                gr.update();

                var implConfig = new GlideRecord("sn_sec_int_impl_config");
                implConfig.addQuery("implementation", instance);
                implConfig.query();
                while (implConfig.next()) {

                    var configName = implConfig.getDisplayValue("configuration");
                    var configVal = gr.getValue(configName);

                    if (configName == 'access_token')
                        configVal = gr.getValue("access_token");
                    if (implConfig.configuration.elem_type == "boolean")
                        implConfig.setValue("value", configVal === "1");
                    else
                        implConfig.setValue("value", configVal);
                    implConfig.update();
                }

                newconfig = {
                    "client_secret": gr.client_secret.getDecryptedValue(),
                    "client_id": gr.getValue("client_id"),
                    "ast_client_id": gr.getValue("ast_client_id"),
                    "tenant": gr.getValue("tenant"),
                    "checkmarxone_api_base_url": gr.getValue("checkmarxone_api_base_url"),
                    "checkmarxone_server_url": gr.getValue("checkmarxone_server_url"),
                    "include_first_detection_date": gr.getValue("include_first_detection_date") === "1",
                    "import_sca": gr.getValue("import_sca") === "1",
                    "import_sast": gr.getValue("import_sast") === "1",
                    "import_kics": gr.getValue("import_kics") === "1",
                    "triaging_in_snow": gr.getValue("triaging_in_snow") === "1",
                    "access_token": gr.access_token.getDecryptedValue(),
                    "vulnerability_threshold_level": gr.getValue("vulnerability_threshold_level"),
                    "list_projects": gr.getValue("list_of_project_id_s"),
                    "log_level": gr.getValue("log_level"),
                };
            } else if (!gs.nil(configId) && configId + '' != '1234' && !gs.nil(accessToken)) { // for other configs
                newconfig = new sn_sec_int.Implementation().getConfiguration(configId);
                newconfig.access_token = accessToken;
            }
            new sn_sec_int.Implementation().setConfiguration(instance, newconfig);
            return true;
        } catch (err) {
            gs.error(this.MSG + " :saveInstanceTokens : Error while saving the access tokens to database." + err);
            throw err;
        }
    },
    //value of sca checkbox
    importScaFlaw: function(configId) {
        return this._getConfig(configId).import_sca;
    },
    //value of sast checkbox
    importSastFlaw: function(configId) {
        return this._getConfig(configId).import_sast;
    },
    //value of kics checkbox
    importKicsFlaw: function(configId) {
        return this._getConfig(configId).import_kics;
    },

    //validate XML
    validateXML: function(body, errorNodeName) {
        if (!body) return;
        var doc = new XMLDocument2();
        doc.parseXML(body);
        var err = null;
        try {
            var root = doc.getFirstNode('/' + doc.getDocumentElement().getNodeName());
            if (errorNodeName && root.getNodeName() == errorNodeName)
                err = root.getTextContent();
            else
                doc.getNextNode(root);
        } catch (e) {
            throw 'XML document syntax invalid';
        }
        if (err)
            throw this.MSG + 'Error: ' + err;
    },

    type: 'CheckmarxOneUtilBase'
};]]></script>
<sys_class_name>sys_script_include</sys_class_name>
<sys_created_by>admin</sys_created_by>
<sys_created_on>2022-11-21 19:26:28</sys_created_on>
<sys_id>1980bcb147935110328ca368436d435a</sys_id>
<sys_mod_count>282</sys_mod_count>
<sys_name>CheckmarxOneUtilBase</sys_name>
<sys_package display_value="Checkmarx One Vulnerability Integration" source="x_chec3_chexone">3d20e92d47471110328ca368436d436a</sys_package>
<sys_policy/>
<sys_scope display_value="Checkmarx One Vulnerability Integration">3d20e92d47471110328ca368436d436a</sys_scope>
<sys_update_name>sys_script_include_1980bcb147935110328ca368436d435a</sys_update_name>
<sys_updated_by>apoorva.singh@checkmarx.com</sys_updated_by>
<sys_updated_on>2024-03-05 11:34:56</sys_updated_on>
</sys_script_include>
</unload>
