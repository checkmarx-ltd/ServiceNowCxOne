<?xml version="1.0" encoding="UTF-8"?>
<unload unload_date="2024-10-11 13:00:36">
<sys_script_include action="INSERT_OR_UPDATE">
<access>public</access>
<active>true</active>
<api_name>x_chec3_chexone.CheckmarxOneUtilBase</api_name>
<caller_access/>
<client_callable>false</client_callable>
<description>Wrapper class to assemble the components for Checkmarx One integration calls.</description>
<name>CheckmarxOneUtilBase</name>
<script><![CDATA[var CheckmarxOneUtilBase = Class.create();

CheckmarxOneUtilBase.prototype = {
    SEC_UTIL: new sn_sec_cmn.SecCommonUtil(),
    MSG: 'CheckmarxOneUtilBase:',
    initialize: function() {},

    //get all project list
    getProjectList: function(configId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var baseUrl = config.checkmarxone_server_url;
            var apiurl = config.checkmarxone_api_base_url;
            var method = "post";
            var query = '/api/projects';
            var token = this.getAccessToken(baseUrl, config, method, request, configId);
        } catch (err) {
            gs.error(this.MSG + " getProjectList : Error while getting the project list." + err);
            throw err;
        }
        return this._makeRestApiCall(apiurl, configId, token, query, "get");
    },

    //get one project from project list for pre Validation
    getProjectListForValidation: function(config) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var configId = "1234";
            var save_token_flag = "false";
            var token = this.getNewToken(accesscontrolbaseUrl, config, method, request, config.client_id, config.client_secret, config.tenant, save_token_flag, configId);
            var query = '/api/projects/?offset=0&limit=1';
        } catch (err) {
            gs.error(this.MSG + " getProjectListForValidation: Error while getting project for validation." + err);
            throw err;
        }
        return this._makeRestCall(apibaseurl, configId, token, query, "get");
    },

    //get one project from project list
    getProject: function(configId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var save_token_flag = "true";
            var token = this.getNewTokenForValidation(accesscontrolbaseUrl, config, method, request, config.client_id, config.client_secret, config.tenant, save_token_flag, configId);
            var query = '/api/projects/?offset=0&limit=1';
        } catch (err) {
            gs.error(this.MSG + " getProject: Error while getting project." + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");
    },

    //get all project list
    getProjects: function(configId) {
        var projectJson = '';
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var save_token_flag = "true";
            var token = this.getNewToken(accesscontrolbaseUrl, config, method, request, config.client_id, config.client_secret, config.tenant, save_token_flag, configId);
            var query = '/api/projects/?offset=0&limit=20000';
            var response = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            projectJson = JSON.parse(response.getBody());
        } catch (err) {
            gs.error(this.MSG + " getProjects: Error while getting projects." + err);
            throw err;
        }
        return projectJson;
    },

    //get ProjectId and Primary Branch list
    getProjectPrimaryBranchList: function(configId) {
        var projectPrimaryBranchList = [];
        try {
            var projectJson = this.getProjects(configId);
            for (var item in projectJson.projects) {
                var id = projectJson.projects[item].id;
                var mainBranch = projectJson.projects[item].mainBranch;
                if (null != mainBranch && mainBranch != "") {
                    var projectPrimaryBranch = id + ':' + mainBranch;
                    projectPrimaryBranchList.push(projectPrimaryBranch);
                }
            }
        } catch (err) {
            gs.error(this.MSG + ' getProjectPrimaryBranchList: error while getting project primary branch list.');
        }
        return projectPrimaryBranchList;
    },

    //get Primary Branch By projectId
    getPrimaryBranchByProjectId: function(projectPrimaryBranchList, projectId) {
        var primaryBranch = '';
        for (var item in projectPrimaryBranchList) {
            var primaryBranchWithProjectId = projectPrimaryBranchList[item];
            if (primaryBranchWithProjectId.indexOf(projectId) != -1) {
                primaryBranch = primaryBranchWithProjectId.split(':')[1];
                break;
            }
        }
        return primaryBranch;
    },

    //get new project list
    getNewProjectList: function(configId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var query = '';
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            query = '/api/projects/?offset=0&limit=1';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);
        } catch (err) {
            gs.error(this.MSG + " getNewProjectList: Error while getting the project list: " + err);
            throw err;
        }
        return projectJSON;
    },

    //To get Lists of project from Configuration Page
    getConfigProjectList: function(configId) {
        try {
            var config = this._getConfig(configId);
            var project_lists = [];
            var list_projects = config.list_of_project_id_s;
            if (list_projects && list_projects.length > 0) {
                var list_project_arr = list_projects.replace("=", ";").split(";");
                for (var id in list_project_arr) {
                    var projectId = list_project_arr[id].trim();
                    if (projectId && projectId.length > 0 && project_lists.indexOf(projectId) == -1)
                        project_lists.push(projectId);
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getConfigProjectList: Error while getting project IDs from config." + err);
            throw err;
        }
        return project_lists;
    },

    //To get the list of project name from Configuration Page
    getConfigProjectNameList: function(configId) {
        try {
            var config = this._getConfig(configId);
            var project_name_lists = [];
            var list_project_name = config.project_filter_by_name;
            if (list_project_name && list_project_name.length > 0) {
                var list_project_name_arr = list_project_name.replace("=", ";").split(";");
                for (var id in list_project_name_arr) {
                    var projectName = list_project_name_arr[id].trim();
                    if (projectName && projectName.length > 0 && project_name_lists.indexOf(projectName) == -1)
                        project_name_lists.push(projectName);
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getConfigProjectNameList: Error while getting project name from config." + err);
            throw err;
        }
        return project_name_lists;
    },

    //get Project By Id
    getConfigProjectById: function(configId, projectId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/projects/' + projectId;
            var resp = this._makeConfigRestApiCall(apibaseurl, configId, token, query, "get");
        } catch (err) {
            gs.error(this.MSG + " getConfigProjectById: Error while getting the details of project present in config." + err);
        }
        return resp;
    },

    // To Get Result state from configuartion	
    getResultStateFromUI: function(configId) {
        try {
            var config = this._getConfig(configId);
            var resultState = config.result_states;
            var result_state = [];
            var resultStateUIArr = resultState.split(',');
            for (var item in resultStateUIArr) {
                result_state.push(resultStateUIArr[item]);
            }

        } catch (err) {
            gs.error(this.MSG + " getResultStateFromUI: Error while getting Result State from Configuration " + err);
        }
        return JSON.stringify(result_state);
    },


    //get 50 project list at a time
    getNextProjectList: function(configId, offsetno) {
        var projects = [];
        var list_projects = [];
        var list_projects_name = [];
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var limit_val = config.limit;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '';
            var projectid = '';
            var filter_project = config.filter_project;
            list_projects = this.getConfigProjectList(configId);
            list_projects_name = this.getConfigProjectNameList(configId);

            if (list_projects && list_projects.length > 0 && list_projects.indexOf('exclude') == -1 && filter_project == 'by_Id') {
                var index = parseInt(offsetno);
                var offsetLength = index + 50;
                if (offsetLength > list_projects.length) {
                    offsetLength = list_projects.length;
                }
                for (var id = index; id < offsetLength; id++) {
                    if (list_projects[id].length > 0) {
                        var projectStatus = this.getConfigProjectById(configId, list_projects[id]);
                        if (projectStatus == 200 || projectStatus == 202)
                            projectid += '&ids=' + list_projects[id];
                        else
                            gs.warn(this.MSG + "Entered project id is not valid: " + list_projects[id]);
                    }
                }
                query = '/api/projects/?limit=' + limit_val + projectid;

            } else {
                query = '/api/projects/?offset=' + offsetno + '&limit=' + limit_val;
            }
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);


            if (list_projects_name && list_projects_name.length > 0 && filter_project == 'by_name') {
                var projectIdsByNames = this.getProjectIdsFromProjectNames(configId, list_projects_name);
            }
            for (var item in projectJSON.projects) {
                if (filter_project == 'by_Id' && list_projects && list_projects.length > 0 && list_projects.indexOf('exclude') != -1 && list_projects.indexOf(projectJSON.projects[item].id.toString()) == -1) {
                    try {
                        var not_exclude_project = this.getProjectById(configId, projectJSON.projects[item].id);
                        projects.push(not_exclude_project);
                    } catch (error) {
                        gs.error(this.MSG + " getProjectById: Failed to get detail about project Id: " + projectJSON.projects[item].id + " with error: " + error);
                        continue;
                    }
                } else if (filter_project == 'by_Id' && list_projects && list_projects.length > 0 && list_projects.indexOf('exclude') == -1 && list_projects.indexOf(projectJSON.projects[item].id.toString()) != -1) {
                    try {
                        var include_project = this.getProjectById(configId, projectJSON.projects[item].id);
                        projects.push(include_project);
                    } catch (error) {
                        gs.error(this.MSG + " getProjectById: Failed to get detail about project Id: " + projectJSON.projects[item].id + " with error: " + error);
                        continue;
                    }
                } else if (filter_project == 'by_name' && list_projects_name && list_projects_name.length > 0 && list_projects_name.indexOf('exclude') != -1 && projectIdsByNames.indexOf(projectJSON.projects[item].id.toString()) == -1) {
                    try {
                        var not_exclude_project_name = this.getProjectById(configId, projectJSON.projects[item].id);
                        projects.push(not_exclude_project_name);
                    } catch (error) {
                        gs.error(this.MSG + " getProjectById: Failed to get detail about project Id: " + projectJSON.projects[item].id + " with error: " + error);
                        continue;
                    }
                } else if (filter_project == 'by_name' && list_projects_name && list_projects_name.length > 0 && list_projects_name.indexOf('exclude') == -1 && projectIdsByNames.indexOf(projectJSON.projects[item].id) != -1) {
                    try {
                        var include_project_name = this.getProjectById(configId, projectJSON.projects[item].id);
                        projects.push(include_project_name);
                    } catch (error) {
                        gs.error(this.MSG + " getProjectById: Failed to get detail about project Id: " + projectJSON.projects[item].id + " with error: " + error);
                        continue;
                    }
                } else if (filter_project == '' || filter_project == null || filter_project == 'none') {
                    try {
                        var project = this.getProjectById(configId, projectJSON.projects[item].id);
                        projects.push(project);
                    } catch (error) {
                        gs.error(this.MSG + " getProjectById: Failed to get detail about project Id: " + projectJSON.projects[item].id + " with error: " + error);
                        continue;
                    }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getNextProjectList: Error while getting the Project details: " + err);
            throw err;
        }
        return projects;
    },

    //get project Ids from the Config Project Name List
    getProjectIdsFromProjectNames: function(configId, list_projects_name) {
        var projectIds = [];
        try {
            var config = this._getConfig(configId);
            var request = new sn_ws.RESTMessageV2();
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/projects/?offset=0&limit=1000&name-regex=';

            var regex = '^.*(';
            for (var id in list_projects_name) {
                if (list_projects_name[id] && null != list_projects_name[id] && '' != list_projects_name[id] && 'undefined' != list_projects_name[id] && list_projects_name[id].indexOf('exclude') == -1) {
                    var escapedProjectName = this.escapeProjectName(list_projects_name[id]);
                    if ((id == 0 && list_projects_name.indexOf('exclude') == -1) || (id == 1 && list_projects_name.indexOf('exclude') != -1))
                        regex += escapedProjectName;
                    else
                        regex += '|' + escapedProjectName;
                }
            }
            regex += ').*$';
            var regex_encode = gs.urlEncode(regex);
            query += regex_encode;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var projectJSON = JSON.parse(resp.getBody());
            if (null != projectJSON.projects) {
                for (var item in projectJSON.projects) {
                    var projectId = projectJSON.projects[item].id;
                    projectIds.push(projectId);
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getProjectIdsFromProjectNames: Error while getting the project Ids from project name." + err);
            throw err;
        }
        return projectIds;
    },

    // Escape Special Chars in ProjectName
    escapeProjectName: function(projectName) {
        var escapedProjectName = '';
        var projectNameArr = projectName.split('');

        var specialChars = ['!', '@', '#', '%', '*', '+', '.', '_', '-', ',', '\'', ':', '"', '`', '~', '>', '<', '$', '^', '&', ')', '(', ']', '[', '}', '{', '/', '\\', '|'];

        for (var item in projectNameArr) {
            if (specialChars.indexOf(projectNameArr[item]) != -1)
                escapedProjectName += '\\' + projectNameArr[item];
            else
                escapedProjectName += projectNameArr[item];
        }

        return escapedProjectName;
    },

    //check if project needs to be included or not
    isProjectIncluded: function(configId, filter_project, list_projects, list_projects_name, projectIdsByNames, projectId) {
        var includeProjectFlag = 'true';

        if (filter_project == 'by_Id' && list_projects && list_projects.length > 0 && list_projects.indexOf('exclude') != -1 && list_projects.indexOf(projectId) != -1) {
            includeProjectFlag = 'false';
        } else if (filter_project == 'by_Id' && list_projects && list_projects.length > 0 && list_projects.indexOf('exclude') == -1 && list_projects.indexOf(projectId) == -1) {
            includeProjectFlag = 'false';
        } else if (filter_project == 'by_name' && list_projects_name && list_projects_name.length > 0 && list_projects_name.indexOf('exclude') != -1 && projectIdsByNames.indexOf(projectId) != -1) {
            includeProjectFlag = 'false';
        } else if (filter_project == 'by_name' && list_projects_name && list_projects_name.length > 0 && list_projects_name.indexOf('exclude') == -1 && projectIdsByNames.indexOf(projectId) == -1) {
            includeProjectFlag = 'false';
        } else if (filter_project == '' || filter_project == null || filter_project == 'none') {
            includeProjectFlag = 'true';
        }
        return includeProjectFlag;
    },

    //get Project By Id
    getProjectById: function(configId, projectId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/projects/' + projectId;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);

        } catch (err) {
            gs.error(this.MSG + " getProjectById: Error while getting the project info: " + err);
            throw err;
        }
        return projectJSON;
    },

    //get Project Branch List
    getProjectBranchList: function(configId, projectId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/projects/branches?offset=0&limit=10000&project-id=' + projectId;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);

        } catch (err) {
            gs.error(this.MSG + " getProjectBranchList: Error while getting the project info: " + err);
            throw err;
        }
        return projectJSON;
    },

    //get Project By Name
    getProjectByName: function(configId, projectName) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/projects/?offset=0&limit=1&name-regex=' + projectName;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var projectJSON = JSON.parse(body);

        } catch (err) {
            gs.error(this.MSG + " getProjectByName: Error while getting the project info by project name." + err);
            throw err;
        }
        return projectJSON;
    },

    //List of project IDs from last_run_date
    getprojectScanList: function(configId, last_run_date) {
        var projectIdsByLastScanDate = [];
        try {
            var includesca = this.importScaFlaw(this.IMPLEMENTATION);
            var includesast = this.importSastFlaw(this.IMPLEMENTATION);
            var includekics = this.importKicsFlaw(this.IMPLEMENTATION);
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=20000&statuses=Completed&from-date=' + last_run_date + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var scanJson = JSON.parse(resp.getBody());

            for (var item in scanJson.scans) {
                var projectId = scanJson.scans[item].projectId;
                var includeProject = 'false';
                if (projectId && projectId != '' && projectId != 'undefined' && projectIdsByLastScanDate.indexOf(projectId) == -1) {
                    if (includesca) {
                        if (scanJson.scans[item].engines.toString().indexOf("sca") != -1) {
                            includeProject = 'true';
                        }
                    }
                    if (includesast) {
                        if (scanJson.scans[item].engines.toString().indexOf("sast") != -1) {
                            includeProject = 'true';
                        }
                    }
                    if (includekics) {
                        if (scanJson.scans[item].engines.toString().indexOf("kics") != -1) {
                            includeProject = 'true';
                        }
                    }
                }
                if (includeProject == 'true')
                    projectIdsByLastScanDate.push(projectId);
            }
        } catch (err) {
            gs.error(this.MSG + " :getprojectScanList :Error while getting Project list from last scan run date: " + err);
        }

        return projectIdsByLastScanDate;

    },

    //List of scans from last_run_date
    getAllScanList: function(configId, last_run_date) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=20000&statuses=Completed&from-date=' + last_run_date + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var scanJson = JSON.parse(resp.getBody());

        } catch (err) {
            gs.error(this.MSG + " :getAllScanList :Error while getting scans from last run date." + err);
        }

        return scanJson;

    },


    //List of scanIds for a given app/project filter by branch name
    getScanListFilterByBranch: function(configId, projectId, last_run_date, branch) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=1&statuses=Completed&project-id=' + projectId + '&from-date=' + last_run_date + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids&branch=' + branch;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
        } catch (err) {
            gs.error(this.MSG + " :getScanListFilterByBranch :Error in getting the scan details with branch filter: " + err);
            return -1;
        }

        return resp;

    },

    //List of scanIds for a given app/project filter by branch name
    getScanListFilterByMultipleBranch: function(configId, projectId, last_run_date, branches) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var branch = '';
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            for (var item in branches) {
                branch += '&branches=' + branches[item];
            }
            var query = '/api/scans/?offset=0&limit=10000&statuses=Completed&project-id=' + projectId + '&from-date=' + last_run_date + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids' + branch;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
        } catch (err) {
            gs.error(this.MSG + " :getScanListFilterByMultipleBranch :Error in getting the scan details with branch filter: " + err);
            return -1;
        }
        return resp;
    },


    //Second Last scanId for a given app/project
    getSecondLastScan: function(configId, projectId, scanId, primaryBranch) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var isPrimaryBranchEnabled = config.sync_only_primary_branch.toString();
            var query = '';
            if (isPrimaryBranchEnabled == 'true' && null != primaryBranch && '' != primaryBranch)
                query = '/api/scans/?offset=0&limit=1000&statuses=Completed&project-id=' + projectId + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids&branch=' + primaryBranch;
            else
                query = '/api/scans/?offset=0&limit=1000&statuses=Completed&project-id=' + projectId + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var secondscan = -1;
            var ScanJson = JSON.parse(body);
            for (var i = 0; i <= ScanJson.scans.length; i++) {
                if (ScanJson.scans[i] != undefined) {
                    if (ScanJson.scans[i].id == scanId && ScanJson.scans[i + 1] != undefined) {
                        secondscan = ScanJson.scans[i + 1].id;
                    }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " :getSecondLastScan :Error in getting the second last scan ID: " + err);
            throw err;
        }
        return secondscan;
    },

    // last  scan details of a given appId 
    getScanInfo: function(configId, appId, offset, last_run_date) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var limit_val = config.limit;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=1&statuses=Completed&project-id=' + appId + '&from-date=' + last_run_date + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';
        } catch (err) {
            gs.error(this.MSG + " getScanInfo: Error while getting the scan info: " + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");

    },

    // last  scan  config details of a given appId  and scanId
    getScanConfigInfo: function(configId, appId, scanId) {
        var responseBody = '';
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/configuration/scan?project-id=' + appId + '&scan-id=' + scanId;
            var response = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            responseBody = JSON.parse(response.getBody());
        } catch (err) {
            gs.error(this.MSG + " getScanConfigInfo: Error while getting the scan configuration info: " + err);
            throw err;
        }
        return responseBody;

    },

    //List of Last scanId for a given app/project
    getLastScan: function(configId, projectId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&amp;limit=1&amp;statuses=Completed&amp;project-id=' + projectId + '&amp;sort=%2Bcreated_at&amp;sort=%2Bstatus&amp;field=scan-ids';

        } catch (err) {
            gs.error(this.MSG + " :getLastScan :Error in getting last scan details." + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");
    },

    // last  scan details of a given scanId 
    getLastScanInfo: function(configId, appId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/' + scanId;
        } catch (err) {
            gs.error(this.MSG + " getScanInfo: Error while getting the last scan info: " + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");

    },


    //scan details of a given scanId
    getQueryInfo: function(configId, scanId) {
        var queryJSON;
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/results/?scan-id=' + scanId + '&offset=0&limit=10000&sort=%2Bstatus&sort=%2Bseverity';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            queryJSON = JSON.parse(body);
        } catch (err) {
            gs.error(this.MSG + " getQueryInfo: Error while getting the Query Info: " + err);
            throw err;
        }
        return queryJSON;

    },

    processQueryData: function(configId, scanId) {
        var queryJSON = this.getQueryInfo(configId, scanId);
        var query = [];
        var index = 0;
        for (item in queryJSON.results) {
            var singleQuery = queryJSON.results[item];
            if (singleQuery.type == 'sast' || singleQuery.type == 'kics') {
                var queryIndex = this.checkQueryIndex(query, singleQuery.data.queryName);
                if (queryIndex != -1)
                    query[queryIndex].count = query[queryIndex].count + 1;
                else {
                    var updatedQuery = {};
                    updatedQuery.category_name = singleQuery.data.queryName;
                    updatedQuery.severity = singleQuery.severity;
                    updatedQuery.count = 1;
                    query[index] = updatedQuery;
                    index++;
                }
            }
        }
        return query;
    },

    checkQueryIndex: function(query, name) {
        for (queryIndex in query)
            if (query[queryIndex].category_name === name)
                return queryIndex;
        return -1;
    },

    // to fetch scan details of particular scanId
    getScanDetails: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/scans/?offset=0&limit=2000&scan-ids=' + scanId + '&sort=%2Bcreated_at&sort=%2Bstatus&field=scan-ids';
        } catch (err) {
            gs.error(this.MSG + " getScanDetails: Error while getting the scan details: " + err);
            throw err;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");

    },

    //to get total  vul item 
    getTotalVulcount: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var includesca = this.importScaFlaw(configId);
            var includesast = this.importSastFlaw(configId);
            var includekics = this.importKicsFlaw(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var vulnerabilityCountThresholdLevel = config.vulnerability_threshold_level;
            var method = "post";
            var count = 0;
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);
            for (var item in ScanSummaryJson.scansSummaries) {

                for (var value in ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters) {
                    var severity = ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters[value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW' && severity.toUpperCase() != 'MEDIUM') ||
                        severity.toUpperCase() == 'CRITICAL') {
                        var counts = ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters[value].counter;
                        count += counts;
                    }
                }

                for (var sca_value in ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters) {
                    var sca_severity = ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters[sca_value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && sca_severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && sca_severity.toUpperCase() != 'INFO' && sca_severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && sca_severity.toUpperCase() != 'INFO' && sca_severity.toUpperCase() != 'LOW' && sca_severity.toUpperCase() != 'MEDIUM') ||
                        sca_severity.toUpperCase() == 'CRITICAL') {
                        var sca_counts = ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters[sca_value].counter;
                        count += sca_counts;
                    }
                }
                for (var sca_container_value in ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters) {
                    var sca_container_severity = ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters[sca_container_value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && sca_container_severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && sca_container_severity.toUpperCase() != 'INFO' && sca_container_severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && sca_container_severity.toUpperCase() != 'INFO' && sca_container_severity.toUpperCase() != 'LOW' && sca_container_severity.toUpperCase() != 'MEDIUM') ||
                        sca_container_severity.toUpperCase() == 'CRITICAL') {
                        var sca_container_counts = ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters[sca_container_value].counter;
                        count += sca_container_counts;
                    }
                }
                for (var kics_value in ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters) {
                    var kics_severity = ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters[kics_value].severity;

                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && kics_severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && kics_severity.toUpperCase() != 'INFO' && kics_severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && kics_severity.toUpperCase() != 'INFO' && kics_severity.toUpperCase() != 'LOW' && kics_severity.toUpperCase() != 'MEDIUM') ||
                        kics_severity.toUpperCase() == 'CRITICAL') {
                        var kics_counts = ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters[kics_value].counter;
                        count += kics_counts;
                    }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getTotalVulcount: Error while getting the total vul count for scanId: " + scanId + " with error: " + err);
            return -1;
        }

        return count;

    },


    //to get SAST  vul item 
    getSASTVulcount: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);

            for (var item in ScanSummaryJson.scansSummaries) {
                var count = ScanSummaryJson.scansSummaries[item].sastCounters.totalCounter;
            }
        } catch (err) {
            gs.error(this.MSG + " getSASTVulcount: Error while getting the SAST vul count for scanId: " + scanId + " with error: " + err);
            return -1;
        }

        return count;

    },

    //to get total SAST and KICS  vul item 
    getTotal_SAST_KICS_Vulcount: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var flaws = 0;
            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);

            for (var item in ScanSummaryJson.scansSummaries) {
                var counts = ScanSummaryJson.scansSummaries[item].sastCounters.totalCounter + ScanSummaryJson.scansSummaries[item].kicsCounters.totalCounter;
                flaws += counts;
            }
        } catch (err) {
            gs.error(this.MSG + " getTotal_SAST_KICS_Vulcount: Error while getting the total sast and kics vul count" + err + scanId);
            return 0;
        }

        return flaws;

    },

    // to get vulnerabilities information of scanId
    getVulInfo: function(configId, scanId, offsetId, delta) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var includesca = this.importScaFlaw(configId);
            var includesast = this.importSastFlaw(configId);
            var includekics = this.importKicsFlaw(configId);

            var limit_val = config.limit;
            var query = '/api/results/?scan-id=' + scanId + '&offset=' + offsetId + '&limit=' + limit_val + '&sort=-severity';
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

        } catch (err) {
            gs.error(this.MSG + " getVulInfo: Error while getting the vul Info: " + err);
            return -1;
        }
        return this._makeRestApiCall(apibaseurl, configId, token, query, "get");

    },

    //Sca scan details of a given scanId
    getScanSummaryInfo: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);
            var flaws = 0;
            var vulnerabilityCountThresholdLevel = config.vulnerability_threshold_level;
            for (var item in ScanSummaryJson.scansSummaries) {
                for (var value in ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters) {
                    var severity = ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters[value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW' && severity.toUpperCase() != 'MEDIUM') ||
                        severity.toUpperCase() == 'CRITICAL') {
                        var counts = ScanSummaryJson.scansSummaries[item].scaCounters.severityCounters[value].counter;
                        flaws += counts;
                    }
                }
                for (value in ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters) {
                    var sca_container_severity = ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters[value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && sca_container_severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && sca_container_severity.toUpperCase() != 'INFO' && sca_container_severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && sca_container_severity.toUpperCase() != 'INFO' && sca_container_severity.toUpperCase() != 'LOW' && sca_container_severity.toUpperCase() != 'MEDIUM') ||
                        sca_container_severity.toUpperCase() == 'CRITICAL') {
                        var sca_container_counts = ScanSummaryJson.scansSummaries[item].scaContainersCounters.severityVulnerabilitiesCounters[value].counter;
                        flaws += sca_container_counts;
                    }
                }
            }

        } catch (err) {
            gs.error(this.MSG + " getScanSummaryInfo: Error while getting the scan summary Ids for scanId: " + scanId + "with error: " + err);
            return -1;

        }
        return flaws;

    },

    //Sast scan details of a given scanId
    getSastScanSummaryInfo: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);
            var flaws = 0;
            var vulnerabilityCountThresholdLevel = config.vulnerability_threshold_level;
            for (var item in ScanSummaryJson.scansSummaries) {
                for (var value in ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters) {
                    var severity = ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters[value].severity;
                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW' && severity.toUpperCase() != 'MEDIUM') ||
                        severity.toUpperCase() == 'CRITICAL') {
                        var counts = ScanSummaryJson.scansSummaries[item].sastCounters.severityCounters[value].counter;
                        flaws += counts;
                    }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getSastScanSummaryInfo: Error while getting the sast scan summary Ids for scanId: " + scanId + "with error: " + err);
            return -1;
        }
        return flaws;

    },

    //Kics scan details of a given scanId
    getKicsScanSummaryInfo: function(configId, scanId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);

            var query = '/api/scan-summary/?scan-ids=' + scanId + '&include-severity-status=true&include-status-counters=true&include-queries=true&include-files=true&apply-predicates=false';
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
            var body = resp.getBody();
            var ScanSummaryJson = JSON.parse(body);
            var flaws = 0;
            var vulnerabilityCountThresholdLevel = config.vulnerability_threshold_level;
            for (var item in ScanSummaryJson.scansSummaries) {
                for (var value in ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters) {
                    var severity = ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters[value].severity;

                    if ((vulnerabilityCountThresholdLevel == 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'LOW' && severity.toUpperCase() != 'INFO') ||
                        (vulnerabilityCountThresholdLevel == 'MEDIUM' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW') ||
                        (vulnerabilityCountThresholdLevel == 'HIGH' && severity.toUpperCase() != 'INFO' && severity.toUpperCase() != 'LOW' && severity.toUpperCase() != 'MEDIUM') ||
                        severity.toUpperCase() == 'CRITICAL') {
                        var counts = ScanSummaryJson.scansSummaries[item].kicsCounters.severityCounters[value].counter;
                        flaws += counts;
                    }
                }
            }
        } catch (err) {
            gs.error(this.MSG + " getKicsScanSummaryInfo: Error while getting the kics scan summary Ids for scanId: " + scanId + "with error: " + err);
            return -1;

        }
        return flaws;

    },

    getDeltaScan: function(configId, appId, scanId, secondlastscan, offsetId) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            // var limit_val = config.limit;
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            // var offset = offsetId * 50;
            var query = '/api/sast-results/compare?scan-id=' + scanId + '&base-scan-id=' + secondlastscan + '&status=FIXED&offset=0&limit=10000'; /* + offset + '&limit=' + limit_val;*/
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
        } catch (err) {
            gs.error(this.MSG + " getDeltaScan: Error while getting the delta state for scanId: " + scanId + "with error: " + err);
            return -1;
        }
        return resp;

    },

    getSCADeltaVul: function(configId, appId, scanId, secondlastscan) {
        try {
            var request = new sn_ws.RESTMessageV2();
            var config = this._getConfig(configId);
            var accesscontrolbaseUrl = config.checkmarxone_server_url;
            var apibaseurl = config.checkmarxone_api_base_url;
            var method = "post";
            var limit_val = config.limit;
            var token = this.getAccessToken(accesscontrolbaseUrl, config, method, request, configId);
            var query = '/api/sca/scan-results/scans/' + scanId + '/compare-risks?previousScanId=' + secondlastscan;
            var resp = this._makeRestApiCall(apibaseurl, configId, token, query, "get");
        } catch (err) {
            gs.error(this.MSG + " getSCADeltaVul: Error while getting the SCA delta state for scanId: " + scanId + "with error: " + err);
            return -1;
        }
        return resp;

    },

    //To get remediation status for state mapping
    getSASTRemediationStatus: function(status, state) {
        try {

            if (state == 'TO_VERIFY' || status == 'FIXED' || status == 'RESOLVED') {
                var remediation_status = status;
            } else {
                remediation_status = state;
            }
        } catch (err) {
            gs.error(this.MSG + " getRemediationStatus: Error while getting the sast remediation status." + err);

        }
        return remediation_status;

    },

    //To get remediation status for state mapping
    getSCARemediationStatus: function(status, state) {
        try {

            if (state == 'NOT_IGNORED' || status == 'FIXED' || status == 'RESOLVED' || state == 'TO_VERIFY') {
                var remediation_status = status;
            } else {
                remediation_status = state;
            }
        } catch (err) {
            gs.error(this.MSG + " getSCARemediationStatus: Error while getting the SCA remediation status." + err);

        }
        return remediation_status;

    },

    //To get remediation status for state mapping
    getKICSRemediationStatus: function(status, state) {
        try {

            if (state == 'NOT_IGNORED' || status == 'FIXED' || status == 'RESOLVED' || state == 'TO_VERIFY') {
                var remediation_status = status;
            } else {
                remediation_status = state;
            }
        } catch (err) {
            gs.error(this.MSG + " getKICSRemediationStatus: Error while getting the kics remediation status." + err);

        }
        return remediation_status;

    },

    getFirstDetectionDate: function() {
        try {
            var configId = '1234';
            var config = this._getConfig(configId);
            var include_first_found = config.include_first_detection_date;
        } catch (err) {
            gs.error(this.MSG + " getFirstDetectionDate: Error while getting the status of getFirstDetectionDate." + err);

        }
        return include_first_found;
    },

    //Devops Integration
    getProjectByLegacyId: function(configId, params) {
        return this._makeRestCallJSON(configId, 'Project list', JSON.parse(params));
    },

    _getConfig: function(configId) {
        try {
            if (configId && configId != '1234') {
                return new sn_sec_int.Implementation().getConfiguration(configId);
            } else {
                var gr = new GlideRecord("x_chec3_chexone_checkmarxone_configuration");
                gr.query();
                gr.next();
                var newconfig = {
                    "client_secret": gr.client_secret.getDecryptedValue(),
                    "client_id": gr.getValue("client_id"),
                    "tenant": gr.getValue("tenant"),
                    "checkmarxone_api_base_url": gr.getValue("checkmarxone_api_base_url"),
                    "checkmarxone_server_url": gr.getValue("checkmarxone_server_url"),
                    "limit": gr.getValue("limit"),
                    "log_level": gr.getValue("log_level"),
                    "include_first_detection_date": gr.getValue("include_first_detection_date") === "1",
                    "import_sca": gr.getValue("import_sca") === "1",
                    "import_sast": gr.getValue("import_sast") === "1",
                    "import_kics": gr.getValue("import_kics") === "1",
                    "triaging_in_snow": gr.getValue("triaging_in_snow") === "1",
                    "access_token": gr.access_token.getDecryptedValue(),
                    "vulnerability_threshold_level": gr.getValue("vulnerability_threshold_level"),
                    "scan_synchronization": gr.getValue("scan_synchronization"),
                    "sync_only_primary_branch": gr.getValue("sync_only_primary_branch") === "1",
                    "list_projects": gr.getValue("list_of_project_id_s"),
                    "result_states": gr.getValue("result_states"),
                    "project_filter_by_name": gr.getValue("project_filter_by_name"),
                    "filter_project": gr.getValue("filter_project"),
                    "scan_type": gr.getValue("scan_type"),
                };
            }
        } catch (err) {
            gs.error(this.MSG + " :_getConfig :Error in getting the configuration." + err);
            throw err;
        }
        return newconfig;
    },

    getAccessToken: function(baseUrl, config, method, request, configId) {
        //to get access token from sn_sec_cmn_int_auth_config table
        var getConfig = this.SEC_UTIL.getConfig(configId);
        var auth_config = getConfig.auth_config;
        return this._getToken(baseUrl, config, method, request, config.client_id, config.client_secret, config.ast_client_id, config.tenant, auth_config, configId);
    },

    _getToken: function(baseUrl, config, method, request, username, password, ast_client_id, tenant, currentToken, configId) {
        try {
            var accessToken = currentToken;
            if (accessToken == null || accessToken == "" || this._isTokenExpired(this._getExpTimeFromAccessToken(accessToken)) || !this._checkClientId(username, accessToken)) {
                gs.info("Token is expired or client Id is changed, Recreating token..");
                var fullUrl = baseUrl + '/auth/realms/' + tenant + '/protocol/openid-connect/token';
                var query = "client_id=" + username + "&grant_type=" + "client_credentials" + "&client_secret=" + password;
                request.setEndpoint(fullUrl);
                request.setHttpMethod(method);
                var log_level = config.log_level;
                request.setLogLevel(log_level);
                request.setRequestBody(query);
                request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                request.setRequestHeader("Accept", "application/json");
                request.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
                //Convert the object to string and set it to Request Body-
                request.setRequestBody(query);
                var response = this._checkResponseStatus(request);
                var responseBody = response.getBody();
                var tokenResponse = JSON.parse(responseBody);
                accessToken = tokenResponse.access_token;
                var tokenexpiretime = this._getTokenExpiredTime(this._getExpTimeFromAccessToken(accessToken));
                var obj = {
                    "expires_on": tokenexpiretime.toString(),
                    "auth_config": accessToken
                };
                //to set access token in sn_sec_cmn_int_auth_config table
                this.SEC_UTIL.setConfig(configId, obj);
            }

        } catch (err) {
            gs.error(this.MSG + " :_getToken : Error while getting the token." + err);
            throw err;
        }
        return accessToken;
    },

    getNewToken: function(baseUrl, config, method, request, username, password, tenant, saveinstanceflag, configId) {

        try {
            var fullUrl = baseUrl + '/auth/realms/' + tenant + '/protocol/openid-connect/token';
            var query = "client_id=" + username + "&grant_type=" + "client_credentials" + "&client_secret=" + password;
            request.setEndpoint(fullUrl);
            request.setHttpMethod(method);
            var log_level = config.log_level;
            request.setLogLevel(log_level);
            request.setRequestBody(query);
            request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            request.setRequestHeader("Accept", "application/json");
            request.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            //Convert the object to string and set it to Request Body-
            request.setRequestBody(query);
            var response = request.execute();
            var status = response.getStatusCode();
            var accessToken = '';
            if (status == 200 || status == 202) {
                var responseBody = response.getBody();
                var tokenResponse = JSON.parse(responseBody);
                accessToken = tokenResponse.access_token;
                if (saveinstanceflag == "true") {
                    var tokenexpiretime = this._getTokenExpiredTime(this._getExpTimeFromAccessToken(accessToken));
                    var obj = {
                        "expires_on": tokenexpiretime.toString(),
                        "auth_config": accessToken
                    };
                    //to set access token in sn_sec_cmn_int_auth_config table
                    this.SEC_UTIL.setConfig(configId, obj);
                }

            }

        } catch (err) {

            gs.error(this.MSG + " :getNewToken : Error while getting the new token." + err);
            throw err;

        }

        return accessToken;

    },

    getNewTokenForValidation: function(baseUrl, config, method, request, username, password, tenant, saveinstanceflag, configId) {
        try {
            var fullUrl = baseUrl + '/auth/realms/' + tenant + '/protocol/openid-connect/token';
            var query = "client_id=" + username + "&grant_type=" + "client_credentials" + "&client_secret=" + password;
            request.setEndpoint(fullUrl);
            request.setHttpMethod(method);
            var log_level = config.log_level;
            request.setLogLevel(log_level);
            request.setRequestBody(query);
            request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            request.setRequestHeader("Accept", "application/json");
            request.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            //Convert the object to string and set it to Request Body-
            request.setRequestBody(query);
            var response = request.execute();
            var status = response.getStatusCode();
            var accessToken = '';
            if (status == 200 || status == 202) {
                var responseBody = response.getBody();
                var tokenResponse = JSON.parse(responseBody);
                accessToken = tokenResponse.access_token;

                var tokenPayload = accessToken.split(".")[1];
                var tokenPayloadJson = JSON.parse(gs.base64Decode(tokenPayload));
                var permissionFlag = 'true';
                var missingPermissions = '';
                if (null != tokenPayloadJson["roles_ast"]) {
                    var permissions = tokenPayloadJson["roles_ast"];
                    var requiredPermissions = this.getRequiredPermission(configId);
                    for (var item in requiredPermissions) {
                        if (permissions.indexOf(requiredPermissions[item]) == -1) {
                            permissionFlag = 'false';
                            if (missingPermissions != '')
                                missingPermissions += ', ';
                            missingPermissions += requiredPermissions[item];
                        }
                    }
                } else {
                    permissionFlag = 'false';
                    missingPermissions = this.getRequiredPermission(configId).toString();
                }
                if (permissionFlag == 'false')
                    throw (new Error('Credential validation failed due to missing Permissions: ' + missingPermissions));


                if (saveinstanceflag == "true") {
                    var tokenexpiretime = this._getTokenExpiredTime(this._getExpTimeFromAccessToken(accessToken));
                    var obj = {
                        "expires_on": tokenexpiretime.toString(),
                        "auth_config": accessToken
                    };
                    //to set access token in sn_sec_cmn_int_auth_config table
                    this.SEC_UTIL.setConfig(configId, obj);
                }

            }

        } catch (err) {

            gs.error(this.MSG + " :getNewTokenForValidation : Error while getting the new token." + err);
            throw err;

        }

        return accessToken;

    },

    // get required permission from config
    getRequiredPermission: function(configId) {
        var config = this._getConfig(configId);
        var requiredPermission = [];
        var requiredPermissionarr;
        var required_permission = config.permission;
        if (required_permission && required_permission.length > 0) {
            requiredPermissionarr = required_permission.split(";");
            for (var id in requiredPermissionarr) {
                requiredPermission.push(requiredPermissionarr[id]);
            }
        }
        return requiredPermission;

    },

    getUserAgentHeaderDetails: function() {
        try {
            var plugin = new GlideRecord("sys_store_app");
            plugin.get("scope", "x_chec3_chexone");
            var pluginname_version = "plugin_name=" + plugin.getValue("name") + ";plugin_version=" + plugin.getValue("version");
            return pluginname_version.toString();
        } catch (err) {
            gs.error(this.MSG + " :_getUserAgentHeaderDetails : Error while getting the plugin name and version." + err);
            throw err;

        }
    },

    //Compare current clientId with accessToken's clientId
    _checkClientId: function(clientId, accessToken) {
        try {
            var tokenPayload = accessToken.split(".")[1];
            var tokenPayloadJson = JSON.parse(gs.base64Decode(tokenPayload));
            var clientIdToken = tokenPayloadJson.azp;
            if (clientId == clientIdToken)
                return true;
            return false;
        } catch (err) {
            gs.error(this.MSG + " :checkClientId :Error in checkClientId." + err);
            return false;
        }

    },
    // Get expiry token from JWT access token
    _getExpTimeFromAccessToken: function(accessToken) {
        try {
            var splittedStr = accessToken.split(".");
            var decodedToken = JSON.parse(gs.base64Decode(splittedStr[1]));
            var expTime = decodedToken.exp;
        } catch (err) {
            gs.error(this.MSG + " :getExpTimeFromAccessToken :Error in getExpTimeFromAccessToken.");
            return 0;
        }
        return expTime;
    },
    // This method checks  if access token is expired or not.
    _isTokenExpired: function(tokenExpTime) {
        try {
            if (tokenExpTime == 0)
                return true;
            var dateTime = new GlideDateTime();
            var currentTime = dateTime.getNumericValue() / 1000;
            currentTime = parseInt(currentTime);
            if (currentTime > tokenExpTime)
                return true;
            else
                return false;
        } catch (err) {
            gs.error(this.MSG + " :isTokenExpired :Error in isTokenExpired()." + err);
            throw err;
        }
    },
    // This method is to return token expiry time.
    _getTokenExpiredTime: function(tokenExpTime) {
        try {
            var token_time = tokenExpTime * 1000;
            var dateTime = new GlideDateTime();
            dateTime.setNumericValue(parseInt(token_time));
            return dateTime.getDisplayValue();
        } catch (err) {
            gs.error(this.MSG + " :_getTokenExpiredTime :Error in _getTokenExpiredTime()." + err);
            throw err;
        }
    },

    _makeRestCall: function(apiurl, configId, token, apiPath, method, params) {
        var request;
        try {
            request = this.setRequestParams(apiurl, configId, token, apiPath, method, params);
        } catch (err) {
            gs.error(this.MSG + " :_makeRestCall :Error in making the REST call");
            throw err;
        }
        var response = request.execute();
        return response;
    },

    setRequestParams: function(baseUrl, configId, token, apiPath, method, params) {
        try {
            var fullUrl = baseUrl + apiPath;
            var r = new sn_ws.RESTMessageV2();
            r.setEndpoint(fullUrl);
            r.setHttpMethod(method);

            if (params) {
                fullUrl += '/?';
                Object.keys(params).forEach(function(key) {
                    r.setQueryParameter(key, params[key]);
                    fullUrl += key + '=' + gs.urlEncode(params[key]) + '&';
                });
                fullUrl = fullUrl.slice(0, fullUrl.length - 1);
            }
            var newHeader = "Bearer " + token;
            r.setRequestHeader('Authorization', newHeader);
            r.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            r.setHttpTimeout(30000);
            var config = this._getConfig(configId);
            var log_level = config.log_level;
            r.setLogLevel(log_level);
        } catch (err) {
            gs.error(this.MSG + " :setRequestParams :Error in setting the reuest params for REST API call");
            throw err;
        }
        return r;
    },

    _checkResponseStatus: function(request) {
        try {
            var endpoint = request.getEndpoint();
            var response = request.execute();
            var status = response.getStatusCode();
            if (status == 200 || status == 202)
                return response;

            if (status <= 0)
                throw gs.getMessage("Request could not be completed: {0} Reason : {1}", [endpoint, response.getErrorMessage()]);
            if (status == 400)
                throw gs.getMessage("Bad request: {0} Reason : {1}", [endpoint, response.getErrorMessage()]);
            if (status == 401)
                throw gs.getMessage("Request not authorized: {0}", [endpoint, response.getErrorMessage()]);
            if (status == 403)
                throw gs.getMessage("Request forbidden: {0}", [endpoint, response.getErrorMessage()]);
            if (status == 404)
                throw gs.getMessage("Request not found: {0}", [endpoint, response.getErrorMessage()]);

            throw gs.getMessage('Checkmarx responded with error code {0} on: {1}', [status, endpoint]);
        } catch (err) {
            gs.error(this.MSG + " :_checkResponseStatus :Error in checking the response of the API call.");
            throw err;
        }
    },

    _makeConfigRestApiCall: function(baseUrl, configId, token, name, method) {
        try {
            var fullUrl = baseUrl + name;
            var r = new sn_ws.RESTMessageV2();
            r.setEndpoint(fullUrl);
            r.setHttpMethod(method);
            var newHeader = "Bearer " + token;
            r.setRequestHeader("Accept", "application/json");
            r.setRequestHeader("Authorization", newHeader);
            r.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            r.setHttpTimeout(30000);
            var config = this._getConfig(configId);
            var log_level = config.log_level;
            r.setLogLevel(log_level);
            var response = r.execute();
            var status = response.getStatusCode();
        } catch (err) {
            gs.error(this.MSG + " :_makeConfigRestApiCall :Error in making API call.");
            throw err;
        }
        return status;
    },

    _makeRestApiCall: function(baseUrl, configId, token, name, method, params) {
        try {
            var fullUrl = baseUrl + name;
            var r = new sn_ws.RESTMessageV2();
            r.setEndpoint(fullUrl);
            r.setHttpMethod(method);

            var newHeader = "Bearer " + token;
            r.setRequestHeader("Accept", "application/json");
            r.setRequestHeader("Authorization", newHeader);
            r.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
            r.setHttpTimeout(30000);
            var config = this._getConfig(configId);
            var log_level = config.log_level;
            r.setLogLevel(log_level);
        } catch (err) {
            gs.error(this.MSG + " :_makeRestApiCall :Error in making API call.");
            throw err;
        }
        return this._checkResponseStatus(r);
    },
    //For DevOps Integration
    _makeRestCallJSON: function(configId, token, name, params, pathParams, body) {
        var requestType = 'GET';
        var r = new sn_ws.RESTMessageV2('x_chec3_chexone.CheckmarxOneJson', name);
        var endpoint = this._getEndpointComponents(r.getEndpoint());
        if (pathParams) {
            Object.keys(pathParams).forEach(function(key) {
                r.setStringParameter(key, pathParams[key]);
                endpoint.path = endpoint.path.replace('${' + key + '}', pathParams[key]);
            });
        }

        if (params) {
            endpoint.path += '?';
            Object.keys(params).forEach(function(key) {
                r.setQueryParameter(key, gs.urlEncode(params[key]));
                endpoint.path += key + '=' + gs.urlEncode(params[key]) + '&';
            });
            endpoint.path = endpoint.path.slice(0, endpoint.path.length - 1);
        }
        if (!gs.nil(body) && body != {}) {
            requestType = 'POST';
            r.setRequestBody(JSON.stringify(body));
        }


        var newHeader = "Bearer " + token;
        r.setRequestHeader("Accept", "application/json");
        r.setRequestHeader("Authorization", newHeader);
        r.setRequestHeader('User-Agent', this.getUserAgentHeaderDetails());
        r.setHttpTimeout(30000);
        return this._checkResponseStatus(r);
    },
    // 2022-12-08T09:33:00.028555Z to 2022-12-08 09:33:00
    parseDate: function(str) {
        var a = str.replace('T', ' ');
        var b = a.replace('T', ' ');
        var c = b.split('.')[0];
        var date = new GlideDateTime(c);
        return date;
    },

    //2022-12-08 09:33:00 to 2022-12-08T09:33:00.028555Z
    parseTZDate: function(str) {
        str1 = str.slice(0, str.length - 9) + 'T';
        str2 = str.slice(-8) + '.028555Z';
        if (str == "" || str == null) {
            str3 = str;
        } else {
            str3 = str1 + str2;
        }
        return str3;

    },

    //value of sca checkbox
    importScaFlaw: function(configId) {
        return this._getConfig(configId).import_sca;
    },
    //value of sast checkbox
    importSastFlaw: function(configId) {
        return this._getConfig(configId).import_sast;
    },
    //value of kics checkbox
    importKicsFlaw: function(configId) {
        return this._getConfig(configId).import_kics;
    },

    //validate XML
    validateXML: function(body, errorNodeName) {
        if (!body) return;
        var doc = new XMLDocument2();
        doc.parseXML(body);
        var err = null;
        try {
            var root = doc.getFirstNode('/' + doc.getDocumentElement().getNodeName());
            if (errorNodeName && root.getNodeName() == errorNodeName)
                err = root.getTextContent();
            else
                doc.getNextNode(root);
        } catch (e) {
            throw 'XML document syntax invalid';
        }
        if (err)
            throw this.MSG + 'Error: ' + err;
    },

    type: 'CheckmarxOneUtilBase'
};]]></script>
<sys_class_name>sys_script_include</sys_class_name>
<sys_created_by>admin</sys_created_by>
<sys_created_on>2022-11-21 19:26:28</sys_created_on>
<sys_id>1980bcb147935110328ca368436d435a</sys_id>
<sys_mod_count>377</sys_mod_count>
<sys_name>CheckmarxOneUtilBase</sys_name>
<sys_package display_value="Checkmarx One Vulnerability Integration" source="x_chec3_chexone">3d20e92d47471110328ca368436d436a</sys_package>
<sys_policy/>
<sys_scope display_value="Checkmarx One Vulnerability Integration">3d20e92d47471110328ca368436d436a</sys_scope>
<sys_update_name>sys_script_include_1980bcb147935110328ca368436d435a</sys_update_name>
<sys_updated_by>admin</sys_updated_by>
<sys_updated_on>2024-10-03 05:12:07</sys_updated_on>
</sys_script_include>
</unload>
